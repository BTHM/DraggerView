package win99.com.miaogu9.view;import android.content.Context;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;import java.util.ArrayList;import win99.com.miaogu9.adapter.RecyclerWrapAdapter;/** * @author sanshu * @data 16/9/13 上午9:31 * @ToDo ${TODO} */public class WrapRecyclerView extends RecyclerView {    private ArrayList<View> mHeaderViews = new ArrayList<>();    private ArrayList<View> mFootViews = new ArrayList<>();    private Adapter mAdapter;    private int     mDownx;    private int     mDowny;    private int STATE=1;    private int STATE_IDEL=0;    private int REFRESH_TO_RELEASE=2;    private int REFRESHING=3;    private int REFRESHED=4;    private int READY_REFRESH=5;    public WrapRecyclerView(Context context) {        this(context, null);    }    public WrapRecyclerView(Context context, AttributeSet attrs) {        this(context, attrs, 0);    }    public WrapRecyclerView(Context context, AttributeSet attrs, int defStyle) {        super(context, attrs, defStyle);        init();    }    private void init() {        this.addOnScrollListener(new OnScrollListener() {            @Override            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {                super.onScrollStateChanged(recyclerView, newState);                LinearLayoutManager layoutManager = (LinearLayoutManager) WrapRecyclerView.this.getLayoutManager();                int lastPosition = layoutManager.findLastCompletelyVisibleItemPosition();                if (newState == SCROLL_STATE_DRAGGING && lastPosition >= getAdapter().getItemCount() - 1) {                    //持续拖动,且最后一个可见的为最后一个条目                    STATE = READY_REFRESH;                }            }            @Override            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {                super.onScrolled(recyclerView, dx, dy);            }        });    }    public void addHeaderView(View view) {        mHeaderViews.clear();        mHeaderViews.add(view);        if (mAdapter != null) {            if (!(mAdapter instanceof RecyclerWrapAdapter)) {                mAdapter = new RecyclerWrapAdapter(mHeaderViews, mFootViews, mAdapter);       //         mAdapter.notifyDataSetChanged();            }        }    }    public void addFootView(View view) {        mFootViews.clear();        mFootViews.add(view);        if (mAdapter != null) {            if (!(mAdapter instanceof RecyclerWrapAdapter)) {                mAdapter = new RecyclerWrapAdapter(mHeaderViews, mFootViews, mAdapter);      //          mAdapter.notifyDataSetChanged();               // this.invalidate();            }        }    }    public void setAdapter(Adapter adapter) {        if (mHeaderViews.isEmpty() && mFootViews.isEmpty()) {            super.setAdapter(adapter);        } else {            adapter = new RecyclerWrapAdapter(mHeaderViews, mFootViews, adapter);            super.setAdapter(adapter);        }        mAdapter = adapter;    }    @Override    public boolean onTouchEvent(MotionEvent e) {        switch (e.getAction()) {            case MotionEvent.ACTION_DOWN:                mDownx = (int) e.getX();                mDowny = (int) e.getY();                break;            case MotionEvent.ACTION_MOVE:                int movex = (int) e.getX();                int movey = (int) e.getY();                if (Math.abs(movey - mDowny) < Math.abs(movex - mDownx)) {                    if (movex - mDownx < 0 && STATE==READY_REFRESH) {                       // requestDisallowInterceptTouchEvent(true);                        STATE=REFRESH_TO_RELEASE;                        System.out.println("REFRESH_TO_RELEASE");                    }else{                        STATE=STATE_IDEL;                    }                   // this.getParent().getParent().getParent().requestDisallowInterceptTouchEvent(false);                }else{                    //requestDisallowInterceptTouchEvent(false);                        getParent().getParent().getParent().requestDisallowInterceptTouchEvent(false);                    System.out.println("this.getParent().getParent().getParent()"+this.getParent().getParent().getParent());                    STATE=STATE_IDEL;                }                mDownx=movex;                break;            case MotionEvent.ACTION_UP:                if (STATE == REFRESH_TO_RELEASE) {                    STATE=REFRESHING;                    mAddViewListener.loadMore();                    STATE=STATE_IDEL;                }                break;            default:        }        return super.onTouchEvent(e);    }    private AddViewListener mAddViewListener;    public interface AddViewListener{        void loadMore();    }    public void setAddViewListener(AddViewListener addViewListener){        mAddViewListener=addViewListener;    }}